#高级人工智能作业 基于蒙特卡洛树搜索的翻翻棋

##环境：python=3.10,numpy



##实现思路

>算法的核心为choose_better函数：给出当前局面下的最优动作
在其中，具体为四个基本流程：选择、拓展、模拟和回溯
对应selection,expansion,simulation and back_propagation
1.selection按照孩子节点的ucb1值来递归选择，直到终局结点或者子结点未全部展开的节点
2.expansion会把一个未展开的结点展开，也就是寻找合法的落子位置，valid_location会返回当前棋盘状态下的所有可能落点，这些可能落点就是当前结点的孩子结点
3.simulation不停地向下模拟扩展，直至到达终局结点，这里的选择是随机的。终局结点代表着游戏的最终状态，在这里我把黑棋胜记为-1，白棋胜记为1。
4.back_propagation会带着终局结点的分数向上回溯，直至到达根节点，在这个过程中，会把回溯的各结点地visit_numbers和value进行修改。
在迭代200次后，choose_better会根据ucb1值选择孩子结点，这就是下一步的动作。

##遇到的一些困难和解决

>“无子可落”的处理。首先是白或黑其中一方没有合法的落子位置，我采取的措施是空走一步，创建一个和父亲结点的棋盘状态一样的结点，相当于只改变结点颜色。然后是黑和白都没有合法的落子位置（这种情况更多在后期出现，也就是棋盘快满时），这时游戏就应该结束了，比较棋盘已有的白和黑数量即可得出胜负，说明只将棋盘下满作为游戏结束的条件是不够的

>合法位置的判断，这个称不上困难，但我觉得处理的不好，很繁琐。具体而言，对每个棋盘状态，遍历每个空位置，检查每个空位置的八个方向符合条件的位置，分别是东南西北和东南、东北、西南、西北这八个方向。考虑过如何减少需要遍历的位置，比如合法位置必然是在已落子位置的边上，这样可以减少遍历量。

##思考和教训

>1.python能力弱。具体来说，基本的语法尚不能灵活运用
2.动手写之前，对整个算法认识的并不够清晰，这带来了大量的问题，包括后续无休无止的debug
3.整个项目应该是低耦合的，也就是函数功能明确，小而精悍是理想状态
4.的确感觉到，编程的思维和能力相比本科就是计算机的同学相差很大
5.copy.deepcopy()的时间开销太大了
6.无论如何，算是完成了最核心的部分，虽然代码很丑，逻辑也不够清晰，最后为了修补双方都无子可下这种情况修修补补，活脱一个裱糊匠
7.刚好第7项，给自己打个7分吧，实现需求，得到锻炼。
